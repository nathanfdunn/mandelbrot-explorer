<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

<canvas id="canvas" style="outline: 1px solid black"></canvas>
<!-- <canvas id="canvas" width="600" height="600"></canvas> -->

<div id="display1">0</div>
<div id="display2">0</div>

<script type="text/javascript">
	// var canvas = document.getElementById('canvas');
	// var ctx = canvas.getContext('2d');
	// ctx.strokeRect(0,0,512,512);

var display1 = document.getElementById('display1');
var display2 = document.getElementById('display2');

var width = 500;
var height = 500;
var canvas = document.getElementById("canvas");
canvas.width = width;
canvas.height = height;
var context = canvas.getContext("2d");

var zoomIntensity = 0.2;
var scale = 1;
// scale = 1.5;
var originx = 0;
var originy = 0;
var visibleWidth = width;
var visibleHeight = height;

var currentLeft, currentRight, currentTop, currentBottom;

// function draw(){
//     // Clear screen to white.
//     context.fillStyle = "white";
//     context.fillRect(originx,originy,800/scale,600/scale);
//     // Draw the black square.
//     context.fillStyle = "black";
//     context.fillRect(50,50,100,100);
// }

function isInSet(a, b) {
	var a2 = 0, b2 = 0;
	for (var i=0; i<100; i++){
		var temp = a2*a2 - b2*b2;
		var temp2 = 2*a2*b2;
		a2 = temp + a;
		b2 = temp2 + b;
	}
	var ret = a2*a2 + b2*b2 < 2;
	return ret;
}

//-2,2 -> 0,512
//x,y -> x*128 + 256

// Draws in real space
var minRe = -2;
var maxRe = 0.5;
var minIm = -1.25;//-1;		//so we can still have a square...?
var maxIm = 1.25;//1;

var minX = 0;
var maxX = width;
var minY = 0;
var maxY = height;

var ratioX = (maxX-minX)/(maxRe-minRe);
var ratioY = (maxY-minY)/(maxIm-minIm);

var inc = 0.005;

var buff = 0.2;
var rectWidth = inc*ratioX+buff;
var rectHeight = inc*ratioY+buff;

var res = 100;		//res * res pixels

function graph(i,j){
	// var x = (i-minRe)*ratioX + minX;
	// var y = (j-minIm)*ratioY + minY;
	// context.fillStyle = 'black';
	// context.fillRect(x,y,rectWidth,rectHeight);
	context.fillStyle = 'black';
	context.fillRect(i,j,1,1);
}
function draw(){
	context.fillStyle = 'white';
    // context.fillRect(originx,originy,width/scale,height/scale);
    context.fillRect(0,0,width,height);
    minRe = minX/width;
    maxRe = maxX/width;
    minIm = minY/width;
    maxIm = maxY/width;

    // There's gotta be a more direct way...
    var myinc = (maxRe - minRe) / res;

    for (var i=0; i<res; i++){
    	for (var j=0; j<res; j++){
    		var re = minRe + i*myinc;
    		var im = minIm + j*myinc;
    		if (isInSet(re,im)){
    			graph(i,j);
    		}
    	}
    }


	for (var i=minRe; i<maxRe; i+=inc){				// real
		for (var j=minIm; j<maxIm; j+=inc){			// imag
			// alert(''+i+','+j+':'+isInSet(i,j));
			if (isInSet(i,j)){
				graph(i,j);
				// for (var k=0; k<10000; k++){}
				// console.log(x,y);
			}
		}
	}
	setTimeout(draw,1000/60);
}

// Draw loop at 60FPS.
// setInterval(draw, 1000/);
setTimeout(draw,1000/60);

canvas.onmousewheel = function (event){
    event.preventDefault();
    // Get mouse offset.
    var mousex = event.clientX - canvas.offsetLeft;
    var mousey = event.clientY - canvas.offsetTop;
    // Normalize wheel to +1 or -1.
    var wheel = event.wheelDelta/120;

    // Compute zoom factor.
    var zoom = Math.exp(wheel*zoomIntensity);

    // Translate so the visible origin is at the context's origin.
    context.translate(originx, originy);
  
    // Compute the new visible origin. Originally the mouse is at a
    // distance mouse/scale from the corner, we want the point under
    // the mouse to remain in the same place after the zoom, but this
    // is at mouse/new_scale away from the corner. Therefore we need to
    // shift the origin (coordinates of the corner) to account for this.
    originx -= mousex/(scale*zoom) - mousex/scale;
    originy -= mousey/(scale*zoom) - mousey/scale;
    
    // Scale it (centered around the origin due to the trasnslate above).
    // context.scale(zoom, zoom);
    // Offset the visible origin to it's proper position.
    // context.translate(-originx, -originy);

    // Update scale and others.
    scale *= zoom;
    // display1.innerHTML = (scale);
    visibleWidth = width / scale;
    visibleHeight = height / scale;


    minX = originx - visibleWidth;
    maxX = originx + visibleWidth;

    minY = originy - visibleHeight;
    maxY = originy + visibleHeight;

    display1.innerHTML = visibleWidth;
    // display1.innerHTML = originx;
    display2.innerHTML = visibleHeight;
    // display2.innerHTML = originy;
}
</script>

</body>
</html>